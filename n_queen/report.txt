最初版本的算法设计：
	每次选择下一个排列前遍历所有可能的情况，选取冲突减少最多的排列。
	为了防止局部最优，当冲突小于一个阈值时，用栈存下所有小于当前冲突的排列，并通过出栈的方式进行递归。
	所有皇后初始位置都在主对角线上。

第一次版本迭代：
	只要找到比当前排列冲突少的排列，就进入下一次迭代。
	计算复杂度时，冲突数时，传入一个当前冲突数，如果计算过程中已经大于当前冲突，则一定不会选这个排列，不需要计算后边的冲突，直接返回即可。
	对于规模较大的问题，为防止局部最优付出的代价过大，设定了一个限制，包括栈大小和每次迭代中存放的点的上限。	
	皇后的位置随机摆放。

最终版本：
	分析发现交换两个皇后的位置后，只需要考察与这两个皇后有关的冲突数，因此在交换前计算与这两个皇后相关的冲突，并在交换后再计算一次，做差就是交换后冲突的变化数，partial_conflict函数（这个函数计算并不严谨，比如计算了自己和自己的冲突，但是由于有做差的过程，并不会对结果造成影响）。
	通过实验发现，对于规模较大的N（500或以上），陷入局部最优的概率很小，对于100以下的问题，陷入局部最优的概率稍大一些，而对于100以下，每次迭代速度都很快。因此，直接删除了栈的使用，在陷入局部最优时，重新随机摆放皇后。
	基于以上两点，直接在每次迭代的最后将冲突数设置为通过由partial_conflict和交换位置前的冲突数计算得到的冲突数，完全计算conflict的函数只在随机拜访皇后后和最后冲突为０做确认时调用。
	最后一个改进是不在每次迭代都从i=0,j=1开始考察，而是每次迭代都记下上次交换的ｉ和ｊ，下次迭代从ｉ＋１和ｊ＋１开始考察。如果一直从i=0,j=1开始，会总是考察很多已经考察过的点，比如说在上一次迭代中，到ｉ＝３００和ｊ＝５００才是使冲突减少的交换，那么在本次中，从ｉ＝０和ｊ＝１开始考察，想要找到与这两排相关的冲突，会考察很多对组合。	

失败的尝试：
	试图采用一定策略的初始化来减少一开始的冲突数，发现都不如随机排列。
	通过一开始时随机若干次来选取冲突最少的初始排列来减少迭代次数，在早先的版本中起到了效果，但最终的版本每次迭代都快了很多，这种策略得不偿失。

测试结果：
问题规模：　采用了partial_conflict后的时间　-> 删除了栈后的时间　->　最终版本的时间(N/A表示未测试，大体上是这样，由于一开始没想到会做这么多类型的尝试，可能有些是其他情况的测试结果)　
100: 2.25 -> 94/100 -> 2/100
200: 45 -> 18.9s -> 6/100
300: 315 -> 1293/10 -> 15/100
500: N/A -> 20/10(这项数据有点问题，具体是什么情况下测试的记不清了) -> 50/100
1000: N/A -> 305/10 -> 314/100
5000: N/A -> 51254/62 -> 3891/20

提交文件：n_queen_local_search_min.cpp是最终的版本，　n_queen_local_search_stack_after_threshold.cpp是较早期的版本。
	
